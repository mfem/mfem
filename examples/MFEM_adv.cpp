//                       MFEM Example 9 - Parallel Version//// Compile with: make ex9p//// Sample runs://    mpirun -np 4 ex9p -m ../data/periodic-segment.mesh -p 0 -dt 0.005//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 0 -dt 0.01//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-hexagon.mesh -p 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/amr-quad.mesh -p 1 -rp 1 -dt 0.002 -tf 9//    mpirun -np 4 ex9p -m ../data/star-q3.mesh -p 1 -rp 1 -dt 0.004 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 1 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/disc-nurbs.mesh -p 2 -rp 1 -dt 0.005 -tf 9//    mpirun -np 4 ex9p -m ../data/periodic-square.mesh -p 3 -rp 2 -dt 0.0025 -tf 9 -vs 20//    mpirun -np 4 ex9p -m ../data/periodic-cube.mesh -p 0 -o 2 -rp 1 -dt 0.01 -tf 8////    MFEM_adv steady-state test runs//    1D//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-segment.mesh -p 0 -dt 5 -s 1 -col 1//    2D//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/inline-quad.mesh -p 0 -dt 5 -s 1 -col 1//    2D AMR//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.005 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 0.2 -s 1 -col 1//    mpirun -np 4 MFEM_adv -m ../data/amr-quad.mesh -p 0 -rp 1 -dt 5 -s 1 -col 1//// Description:  This example code solves the time-dependent advection equation//               du/dt + v.grad(u) = 0, where v is a given fluid velocity, and//               u0(x)=u(0,x) is a given initial condition.////               The example demonstrates the use of Discontinuous Galerkin (DG)//               bilinear forms in MFEM (face integrators), the use of explicit//               ODE time integrators, the definition of periodic boundary//               conditions through periodic meshes, as well as the use of GLVis//               for persistent visualization of a time-evolving solution. The//               saving of time-dependent data files for external visualization//               with VisIt (visit.llnl.gov) is also illustrated.// This problem seems to like an FFC rekaxation...#include "mfem.hpp"#include <fstream>#include <iostream>using namespace std;using namespace mfem;// Choice for the problem setup. The fluid velocity, initial condition and// inflow boundary condition are chosen based on this parameter.int problem;// Collision frequency cross section.double sigma = 0.0;// Tolerance to solve linear system todouble solve_tol;int use_gmres;int myid;// Velocity coefficientvoid velocity_function(const Vector &x, Vector &v);// Initial conditiondouble u0_function(const Vector &x);// Inflow boundary conditiondouble inflow_function(const Vector &x);// Source of particlesdouble sigmaQ_function(const Vector &x);// Mesh bounding boxVector bb_min, bb_max;struct AIR_parameters {   // Options: LAIR: {1, 1.5, 2}, NAIR: {3, 4, 5} - default 1.5   //    LAIR is more robust on non-triangular matrices, NAIR should be   //    faster to setup at the cost of slightly degraded convergence.    //    E.g., NAIR 4 corresponds to distance 4-2=2 restriction.   double distance;   // Options string consisting of F, C, or A; e.g., "FFC" or "FA"   //    Default: prerelax = "", postrelax = "FA" (FA specifically   //    for type 10 relax)   std::string prerelax;   std::string postrelax;   // Strength tolerance for coarsening. Default 0.1, can be problem   // dependent. Try between 0.01 and 0.5, typically in the middle.   double strength_tolC;   // Tolerance for building restriction. Smaller is better, typically    // 0.01 (default) or so.    double strength_tolR;   // Remove small entries from R. Default 0, strategy we are testing to   // reduce complexity.    double filter_tolR;   // Default 100 (simple interpolation). Can also use 6 (classical interp).   int interp_type;   // Default 10 (processor block Jacobi, i.e., ordered on processor Gauss-   // Seidel). Can also use 0 (Jacobi) or 3 (on processor, unordered Gauss-   // Seidel)   int relax_type;   // Eliminate small entries from the matrix to reduce memory/complexity.   // Default 1e-4. Can degrade convergence, if so make smaller.   double filterA_tol;   // Default 6, coarsens not aggressively. Can also use 3 (slower in    // parallel, also not aggressive coarsening) or 10 (more aggressive   // coarsening).   int coarsening;};void print_AIR(AIR_parameters AIR) {   std::cout << "Distance R:   " << AIR.distance << "\n" \             << "Prerelax:     " << AIR.prerelax << "\n" \             << "Postrelax:    " << AIR.postrelax << "\n" \             << "Strength C:   " << AIR.strength_tolC << "\n" \             << "Strength R:   " << AIR.strength_tolR << "\n" \             << "Interp type:  " << AIR.interp_type << "\n" \             << "Relax type:   " << AIR.relax_type << "\n" \             << "Coarsen type: " << AIR.coarsening << "\n" \             << "Filter tol:   " << AIR.filterA_tol << ".\n";}/** A time-dependent operator for the right-hand side of the ODE. The DG weak    form of du/dt = -v.grad(u) + sigma (q - u) is M du/dt = K u + b, where M     and K are the mass and the advection minus the absorption matrices, and b     describes the volumetric source and the flow on the boundary. This can be     written as a general ODE, du/dt = M^{-1} (K u + b), and this class     is used to evaluate the right-hand side. */class FE_Evolution : public TimeDependentOperator{private:   HypreParMatrix &M, &K, *T; // T = M - dt K;   const Vector &b;   HypreSmoother M_prec;   CGSolver M_solver;   /* Precond/Solver for T */   HypreBoomerAMG *AMG_solver;   HypreGMRES     *GMRES_solver;   /* scaled version of T and z */   HypreParMatrix T_s;   mutable Vector z;   double current_dt;   int blocksize;   AIR_parameters AIR;public:   FE_Evolution(HypreParMatrix &_M, HypreParMatrix &_K, const Vector &_b,                 const int order, const AIR_parameters *AIR_init=NULL);   virtual void Mult(const Vector &x, Vector &y) const;   /** Solve the Backward-Euler equation: d = f(x + dt*d, t+dt), where u_t = f(x,t).       This is the only requirement for high-order SDIRK implicit integration.*/   virtual void ImplicitSolve(const double dt, const Vector &u, Vector &k);   void Destroy()   {      BlockInvScal(NULL, NULL, NULL, NULL, 0, -1);      if (T) delete T;      if (AMG_solver) delete AMG_solver;      if (GMRES_solver) delete GMRES_solver;   }   //virtual ~FE_Evolution() { }};int main(int argc, char *argv[]){   // 1. Initialize MPI.   int num_procs;   MPI_Init(&argc, &argv);   MPI_Comm_size(MPI_COMM_WORLD, &num_procs);   MPI_Comm_rank(MPI_COMM_WORLD, &myid);   // 2. Parse command-line options.   problem = 0;   solve_tol = 1e-8;   use_gmres = 0;   const char *mesh_file = "./meshes/periodic-hexagon.mesh";   int ser_ref_levels = 2;   int par_ref_levels = 0;   int order = 3;   int ode_solver_type = 14;   double t_final = 10.0;   double dt = 0.1;   int num_time_steps = -1;   bool visualization = true;   bool visit = false;   bool binary = false;   int vis_steps = 5;   int precision = 8;   cout.precision(precision);   AIR_parameters AIR = {1.5, "", "FA", 0.1, 0.01, 0.0, 100, 10, 0.0001, 6};   const char* temp_prerelax = NULL;   const char* temp_postrelax = NULL;   double h_min, h_max, k_min, k_max;   OptionsParser args(argc, argv);   args.AddOption(&mesh_file, "-m", "--mesh",                  "Mesh file to use.");   args.AddOption(&problem, "-p", "--problem",                  "Problem setup to use. See options in velocity_function().");   args.AddOption(&ser_ref_levels, "-rs", "--refine-serial",                  "Number of times to refine the mesh uniformly in serial.");   args.AddOption(&par_ref_levels, "-rp", "--refine-parallel",                  "Number of times to refine the mesh uniformly in parallel.");   args.AddOption(&order, "-o", "--order",                  "Order (degree) of the finite elements.");   args.AddOption(&use_gmres, "-gmres", "--use-gmres",                  "Boolean to use GMRES acceleration with AIR.");   args.AddOption(&ode_solver_type, "-s", "--ode-solver",                  "ODE solver: 1 - Backward Euler, 2 - SDIRK2, 3 - SDIRK3,\n\t"                  "\t   11 - Forward Euler, 12 - RK2, 13 - RK3 SSP, 14 - RK4,\n\t"                  "\t   22 - Imp. midpoint, 23 - A-stable SDIRK3, 34 - A-stable SDIRK4.");   args.AddOption(&t_final, "-tf", "--t-final",                  "Final time; start time is 0.");   args.AddOption(&num_time_steps, "-nt", "--num-time-steps",                  "Number of time steps to take. Uses dt and overrides final time.");   args.AddOption(&solve_tol, "-tol", "--tolerance",                  "Tolerance to solve linear system to. Use -1 for tol=dt.");   args.AddOption(&dt, "-dt", "--time-step",                  "Time step. If dt = z < 0, dt := h^z, for mesh size h.");   args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",                  "--no-visualization",                  "Enable or disable GLVis visualization.");   args.AddOption(&visit, "-visit", "--visit-datafiles", "-no-visit",                  "--no-visit-datafiles",                  "Save data files for VisIt (visit.llnl.gov) visualization.");   args.AddOption(&binary, "-binary", "--binary-datafiles", "-ascii",                  "--ascii-datafiles",                  "Use binary (Sidre) or ascii format for VisIt data files.");   args.AddOption(&vis_steps, "-vs", "--visualization-steps",                  "Visualize every n-th timestep.");   args.AddOption(&sigma, "-col", "--sigma-collisions",                  "Collision frequency cross section.");    args.AddOption(&(AIR.distance), "-Ad", "--AIR-distance",                  "Distance restriction neighborhood for AIR.");    args.AddOption(&(AIR.interp_type), "-Ai", "--AIR-interpolation",                  "Index for hypre interpolation routine.");    args.AddOption(&(AIR.coarsening), "-Ac", "--AIR-coarsening",                  "Index for hypre coarsening routine.");    args.AddOption(&(AIR.strength_tolC), "-AsC", "--AIR-strengthC",                   "Theta value determining strong connections for AIR (coarsening).");    args.AddOption(&(AIR.strength_tolR), "-AsR", "--AIR-strengthR",                   "Theta value determining strong connections for AIR (restriction).");    args.AddOption(&(AIR.filter_tolR), "-AfR", "--AIR-filterR",                   "Theta value eliminating small entries in restriction (after building).");    args.AddOption(&(AIR.filterA_tol), "-Af", "--AIR-filter",                  "Theta value to eliminate small connections in AIR hierarchy. Use -1 to specify O(h).");    args.AddOption(&(AIR.relax_type), "-Ar", "--AIR-relaxation",                  "Index for hypre relaxation routine.");    args.AddOption(&temp_prerelax, "-Ar1", "--AIR-prerelax",                  "String denoting prerelaxation scheme; e.g., FCC.");    args.AddOption(&temp_postrelax, "-Ar2", "--AIR-postrelax",                  "String denoting postrelaxation scheme; e.g., FFC.");   args.Parse();   if (temp_prerelax != NULL) AIR.prerelax = std::string(temp_prerelax);   if (temp_postrelax != NULL) AIR.postrelax = std::string(temp_postrelax);   if (!args.Good())   {      if (myid == 0)      {         args.PrintUsage(cout);      }      MPI_Finalize();      return 1;   }   if (myid == 0)   {      // args.PrintOptions(cout);   }   // 3. Read the serial mesh from the given mesh file on all processors. We can   //    handle geometrically periodic meshes in this code.   Mesh *mesh = new Mesh(mesh_file, 1, 1);   int dim = mesh->Dimension();   // 4. Define the ODE solver used for time integration. Several explicit   //    Runge-Kutta methods are available.   ODESolver *ode_solver = NULL;   switch (ode_solver_type)   {      // Implicit L-stable methods      case 1:  ode_solver = new BackwardEulerSolver; break;      case 2:  ode_solver = new SDIRK23Solver(2); break;      case 3:  ode_solver = new SDIRK33Solver; break;      // Explicit methods      case 11: ode_solver = new ForwardEulerSolver; break;      case 12: ode_solver = new RK2Solver(0.5); break; // midpoint method      case 13: ode_solver = new RK3SSPSolver; break;      case 14: ode_solver = new RK4Solver; break;      // Implicit A-stable methods (not L-stable)      case 22: ode_solver = new ImplicitMidpointSolver; break;      case 23: ode_solver = new SDIRK23Solver; break;      case 24: ode_solver = new SDIRK34Solver; break;      default:         cout << "Unknown ODE solver type: " << ode_solver_type << '\n';         return 3;   }   // 5. Refine the mesh in serial to increase the resolution. In this example   //    we do 'ser_ref_levels' of uniform refinement, where 'ser_ref_levels' is   //    a command-line parameter. If the mesh is of NURBS type, we convert it   //    to a (piecewise-polynomial) high-order mesh.   for (int lev = 0; lev < ser_ref_levels; lev++)   {      mesh->UniformRefinement();   }   if (mesh->NURBSext)   {      mesh->SetCurvature(max(order, 1));   }   mesh->GetBoundingBox(bb_min, bb_max, max(order, 1));   // 6. Define the parallel mesh by a partitioning of the serial mesh. Refine   //    this mesh further in parallel to increase the resolution. Once the   //    parallel mesh is defined, the serial mesh can be deleted.   ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);   delete mesh;   for (int lev = 0; lev < par_ref_levels; lev++)   {      pmesh->UniformRefinement();   }   // Get mesh size, set time step and solve tol accordingly, if specified   pmesh->GetCharacteristics(h_min, h_max, k_min, k_max);   if (dt < 0) dt = pow(h_max,-dt);   if (solve_tol < 0) {      solve_tol = dt;      if (myid == 0) std::cout << "Solve tolerance = dt = " << dt << "\n";   }   // 7. Define the parallel discontinuous DG finite element space on the   //    parallel refined mesh of the given polynomial order.   DG_FECollection fec(order, dim);   ParFiniteElementSpace *fes = new ParFiniteElementSpace(pmesh, &fec);   HYPRE_Int global_vSize = fes->GlobalTrueVSize();   if (myid == 0) {      cout << "Number of unknowns: " << global_vSize << endl;      cout << "Block size: " << (order+1)*(order+1) << endl;   }   // 8. Set up and assemble the parallel bilinear and linear forms (and the   //    parallel hypre matrices) corresponding to the DG discretization. The   //    DGTraceIntegrator involves integrals over mesh interior faces.   VectorFunctionCoefficient velocity(dim, velocity_function);   FunctionCoefficient inflow(inflow_function);   FunctionCoefficient u0(u0_function);   ParBilinearForm *m = new ParBilinearForm(fes);   m->AddDomainIntegrator(new MassIntegrator);   ParBilinearForm *k = new ParBilinearForm(fes);     k->AddDomainIntegrator(new ConvectionIntegrator(velocity, -1.0));   k->AddInteriorFaceIntegrator(      new TransposeIntegrator(new DGTraceIntegrator(velocity, 1.0, -0.5)));   k->AddBdrFaceIntegrator(      new TransposeIntegrator(new DGTraceIntegrator(velocity, 1.0, -0.5)));   // Subtract the absorption matrix.   ConstantCoefficient sigma_cf(-1.0 * sigma);       k->AddDomainIntegrator(new MassIntegrator(sigma_cf));   ParLinearForm *b = new ParLinearForm(fes);   b->AddBdrFaceIntegrator(new BoundaryFlowIntegrator(inflow, velocity, -1.0, -0.5));   // Add source of particles.      FunctionCoefficient sigmaQ_cf(sigmaQ_function);   b->AddDomainIntegrator(new DomainLFIntegrator(sigmaQ_cf));   m->Assemble();   m->Finalize();   int skip_zeros = 0;   k->Assemble(skip_zeros);   k->Finalize(skip_zeros);   b->Assemble();   HypreParMatrix *M = m->ParallelAssemble();   HypreParMatrix *K = k->ParallelAssemble();   HypreParVector *B = b->ParallelAssemble();   // 9. Define the initial conditions, save the corresponding grid function to   //    a file and (optionally) save data in the VisIt format and initialize   //    GLVis visualization.   ParGridFunction *u = new ParGridFunction(fes);   u->ProjectCoefficient(u0);   HypreParVector *U = u->GetTrueDofs();   {      ostringstream mesh_name, sol_name;      mesh_name << "ex9-mesh." << setfill('0') << setw(6) << myid;      sol_name << "ex9-init." << setfill('0') << setw(6) << myid;      ofstream omesh(mesh_name.str().c_str());      omesh.precision(precision);      pmesh->Print(omesh);      ofstream osol(sol_name.str().c_str());      osol.precision(precision);      u->Save(osol);   }   // Create data collection for solution output: either VisItDataCollection for   // ascii data files, or SidreDataCollection for binary data files.   DataCollection *dc = NULL;   if (visit)   {      if (binary)      {#ifdef MFEM_USE_SIDRE         dc = new SidreDataCollection("Example9-Parallel", pmesh);#else         MFEM_ABORT("Must build with MFEM_USE_SIDRE=YES for binary output.");#endif      }      else      {         dc = new VisItDataCollection("Example9-Parallel", pmesh);         dc->SetPrecision(precision);         // To save the mesh using MFEM's parallel mesh format:         // dc->SetFormat(DataCollection::PARALLEL_FORMAT);      }      dc->RegisterField("solution", u);      dc->SetCycle(0);      dc->SetTime(0.0);      dc->Save();   }   socketstream sout;   if (visualization)   {      char vishost[] = "localhost";      int  visport   = 19916;      sout.open(vishost, visport);      if (!sout)      {         if (myid == 0)            cout << "Unable to connect to GLVis server at "                 << vishost << ':' << visport << endl;         visualization = false;         if (myid == 0)         {            cout << "GLVis visualization disabled.\n";         }      }      else      {         sout << "parallel " << num_procs << " " << myid << "\n";         sout.precision(precision);         sout << "solution\n" << *pmesh << *u;         sout << "pause\n";         sout << flush;         if (myid == 0)            cout << "GLVis visualization paused."                 << " Press space (in the GLVis window) to resume it.\n";      }   }   // 10. Define the time-dependent evolution operator describing the ODE   //     right-hand side, and perform time-integration (looping over the time   //     iterations, ti, with a time-step dt).   FE_Evolution adv(*M, *K, *B, order, &AIR);   double t = 0.0;   if (num_time_steps > 0) t_final = num_time_steps * dt;   adv.SetTime(t);   ode_solver->Init(adv);   bool done = false;   for (int ti = 0; !done; )   {      double dt_real = min(dt, t_final - t);      ode_solver->Step(*U, t, dt_real);      ti++;      done = (t >= t_final - 1e-8*dt);      if (done || ti % vis_steps == 0)      {         if (myid == 0)         {            cout << "time step: " << ti << ", time: " << t << endl;         }         // 11. Extract the parallel grid function corresponding to the finite         //     element approximation U (the local solution on each processor).         *u = *U;// /* @MH         if (visualization)         {            sout << "parallel " << num_procs << " " << myid << "\n";            sout << "solution\n" << *pmesh << *u << flush;         }         if (visit)         {            dc->SetCycle(ti);            dc->SetTime(t);            dc->Save();         }// */      }   }   // 13. Free the used memory.   delete U;   delete u;   delete B;   delete b;   delete K;   delete k;   delete M;   delete m;   delete fes;   delete pmesh;   delete ode_solver;   adv.Destroy();   MPI_Finalize();   return 0;}// Implementation of class FE_EvolutionFE_Evolution::FE_Evolution(HypreParMatrix &_M, HypreParMatrix &_K,                           const Vector &_b, const int order,                           const AIR_parameters *AIR_init)   : TimeDependentOperator(_M.Height()), M(_M), K(_K), b(_b),                            M_solver(M.GetComm()), z(_M.Height()){   M_prec.SetType(HypreSmoother::Jacobi);   M_solver.SetPreconditioner(M_prec);   M_solver.SetOperator(M);   M_solver.iterative_mode = false;   M_solver.SetRelTol(1e-9);   M_solver.SetAbsTol(0.0);   M_solver.SetMaxIter(100);   M_solver.SetPrintLevel(0);   T = NULL;   AMG_solver = NULL;   GMRES_solver = NULL;   if (AIR_init) AIR = *AIR_init;   // DG block size given by (FEorder+1)^2 on square meshes.   blocksize = (order+1)*(order+1);}void FE_Evolution::Mult(const Vector &x, Vector &y) const{   // y = M^{-1} (K x + b)   K.Mult(x, z);   z += b;   M_solver.Mult(z, y);}void FE_Evolution::ImplicitSolve(const double dt, const Vector &u, Vector &du_dt){   HypreParVector z_s;   // Solve the equation:   //    u_t = M^{-1}(Ku + b),    // by solving associated linear system   //    (M - dt*K) d = K*u + b   //    TODO: Is mass matrix lower triangular??   if (!T) {      /* T is NULL, this should be the first solve with T,       * scale T, setup AMG and GMRES */      T = HypreParMatrixAdd(1.0, M, -1.0*dt, K);      current_dt = dt;      /* scale T by block-diagonal inverse */      BlockInvScal(T, &T_s, NULL, NULL, blocksize, 0);      if (myid == 0) std::cout << "assembled matrices: " << T->GetNumRows() << ", " \                               << T->GetNumCols() << ", " << T->NNZ() << "\n";      AMG_solver = new HypreBoomerAMG(T_s);      AMG_solver->SetLAIROptions(AIR.distance, AIR.prerelax, AIR.postrelax,                                 AIR.strength_tolC, AIR.strength_tolR, AIR.filter_tolR,                                 AIR.interp_type, AIR.relax_type, AIR.filterA_tol,                                 AIR.coarsening);      if (!use_gmres) {         AMG_solver->SetPrintLevel(2);         AMG_solver->SetTol(solve_tol);         AMG_solver->SetMaxIter(500);      }      else {         GMRES_solver = new HypreGMRES(T_s);         GMRES_solver->SetAbsTol(solve_tol);         GMRES_solver->SetMaxIter(500);         GMRES_solver->SetPrintLevel(1);         GMRES_solver->SetPreconditioner(*AMG_solver);         /* TODO zero init guess ? */         GMRES_solver->SetZeroInintialIterate();         GMRES_solver->iterative_mode = false;      }   }   MFEM_VERIFY(dt == current_dt, ""); // SDIRK methods use the same dt   K.Mult(u, z);   z += b;   /* scale the rhs and solve system */   BlockInvScal(T, NULL, &z, &z_s, blocksize, 2);   if (use_gmres){      GMRES_solver->Mult(z_s, du_dt);   }   else {      AMG_solver->Mult(z_s, du_dt);   }   /*   static int counter = 0;   counter ++;   T->Mult(-1.0, du_dt, 1.0, z);   printf("res %e\n", ParNormlp(z, 2.0, MPI_COMM_WORLD));   if (counter == 3) { exit(0); }   */}// Velocity coefficientvoid velocity_function(const Vector &x, Vector &v){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);   }   switch (problem)   {      case 0:      {         // Translations in 1D, 2D, and 3D         switch (dim)         {            case 1: v(0) = 1.0; break;            case 2: v(0) = sqrt(2./3.); v(1) = sqrt(1./3.); break;            case 3: v(0) = sqrt(3./6.); v(1) = sqrt(2./6.); v(2) = sqrt(1./6.);               break;         }         break;      }      case 1:      case 2:      {         // Clockwise rotation in 2D around the origin         const double w = M_PI/2;         switch (dim)         {            case 1: v(0) = 1.0; break;            case 2: v(0) = w*X(1); v(1) = -w*X(0); break;            case 3: v(0) = w*X(1); v(1) = -w*X(0); v(2) = 0.0; break;         }         break;      }      case 3:      {         // Clockwise twisting rotation in 2D around the origin         const double w = M_PI/2;         double d = max((X(0)+1.)*(1.-X(0)),0.) * max((X(1)+1.)*(1.-X(1)),0.);         d = d*d;         switch (dim)         {            case 1: v(0) = 1.0; break;            case 2: v(0) = d*w*X(1); v(1) = -d*w*X(0); break;            case 3: v(0) = d*w*X(1); v(1) = -d*w*X(0); v(2) = 0.0; break;         }         break;      }   }}// Initial conditiondouble u0_function(const Vector &x){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);   }   switch (problem)   {      case 0:      case 1:      {         switch (dim)         {            case 1:               return exp(-40.*pow(X(0)-0.5,2));            case 2:            case 3:            {               double rx = 0.45, ry = 0.25, cx = 0., cy = -0.2, w = 10.;               if (dim == 3)               {                  const double s = (1. + 0.25*cos(2*M_PI*X(2)));                  rx *= s;                  ry *= s;               }               return ( erfc(w*(X(0)-cx-rx))*erfc(-w*(X(0)-cx+rx)) *                        erfc(w*(X(1)-cy-ry))*erfc(-w*(X(1)-cy+ry)) )/16;            }         }      }      case 2:      {         double x_ = X(0), y_ = X(1), rho, phi;         rho = hypot(x_, y_);         phi = atan2(y_, x_);         return pow(sin(M_PI*rho),2)*sin(3*phi);      }      case 3:      {         const double f = M_PI;         return sin(f*X(0))*sin(f*X(1));      }   }   return 0.0;}// Inflow boundary condition (zero for the problems considered in this example)double inflow_function(const Vector &x){   switch (problem)   {      case 0:      case 1:      case 2:      case 3: return 0.0;   }   return 0.0;}// Source of particlesdouble sigmaQ_function(const Vector &x){   int dim = x.Size();   // map to the reference [-1,1] domain   Vector X(dim);   double X2 = 0.0;   for (int i = 0; i < dim; i++)   {      double center = (bb_min[i] + bb_max[i]) * 0.5;      X(i) = 2 * (x(i) - center) / (bb_max[i] - bb_min[i]);      X2 += pow(X(i), 2);   }   switch (problem)   {      case 0: return sigma * exp(-10.*X2);      case 1: return 0.0;   }   return 0.0;}
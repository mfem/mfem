// Copyright (c) 2010, Lawrence Livermore National Security, LLC. Produced at
// the Lawrence Livermore National Laboratory. LLNL-CODE-443211. All Rights
// reserved. See file COPYRIGHT for details.
//
// This file is part of the MFEM library. For more information and source code
// availability see http://mfem.org.
//
// MFEM is free software; you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License (as published by the Free
// Software Foundation) version 2.1 dated February 1999.

#include "occa://mfem/fem/defines.okl"

//---[ 1D ]-----------------------------
@kernel void Assemble1D(const int numElements,
                       const double * restrict quadWeights,
                       const Jacobian1D_t restrict J,
                       COEFF_ARGS
                       SymmOperator1D_t restrict oper) {
  for (int e = 0; e < numElements; ++e; @outer) {
    for (int q = 0; q < NUM_QUAD_1D; ++q; @inner) {
      oper(q, e) = quadWeights[q] * COEFF / J(q, e);
    }
  }
}

@kernel void MultAdd1D(const int numElements,
                      const DofToQuad_t restrict dofToQuad,
                      const DofToQuad_t restrict dofToQuadD,
                      const QuadToDof_t restrict quadToDof,
                      const QuadToDof_t restrict quadToDofD,
                      const SymmOperator1D_t restrict oper,
                      const DLocal1D_t restrict solIn,
                      DLocal1D_t restrict solOut) {
  // Iterate over elements
  for (int e = 0; e < numElements; ++e; @outer) {
    for (int dummy = 0; dummy < 1; ++dummy; @inner) {
      double grad[NUM_QUAD_1D];
      for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
        grad[qx] = 0;
      }
      for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
        const double s = solIn(dx, e);
        for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
          grad[qx] += s * dofToQuadD(qx, dx);
        }
      }
      for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
        grad[qx] *= oper(qx, e);
      }
      for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
        const double gradX = grad[qx];
        for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
          solOut(dx, e) += gradX * quadToDofD(dx, qx);
        }
      }
    }
  }
}
//======================================


//---[ 2D ]-----------------------------
@kernel void Assemble2D(const int numElements,
                       const double * restrict quadWeights,
                       const Jacobian2D_t restrict J,
                       COEFF_ARGS
                       SymmOperator2D_t restrict oper) {
  for (int e = 0; e < numElements; ++e; @outer) {
    for (int q = 0; q < NUM_QUAD_2D; ++q; @inner) {
      const double J11 = J(0, 0, q, e), J12 = J(1, 0, q, e);
      const double J21 = J(0, 1, q, e), J22 = J(1, 1, q, e);

      const double c_detJ = quadWeights[q] * COEFF / ((J11 * J22) - (J21 * J12));

      oper(0, q, e) =  c_detJ * (J21*J21 + J22*J22); // (1,1)
      oper(1, q, e) = -c_detJ * (J21*J11 + J22*J12); // (1,2), (2,1)
      oper(2, q, e) =  c_detJ * (J11*J11 + J12*J12); // (2,2)
    }
  }
}

@kernel void MultAdd2D(const int numElements,
                      const DofToQuad_t restrict dofToQuad,
                      const DofToQuad_t restrict dofToQuadD,
                      const QuadToDof_t restrict quadToDof,
                      const QuadToDof_t restrict quadToDofD,
                      const SymmOperator2D_t restrict oper,
                      const DLocal2D_t restrict solIn,
                      DLocal2D_t restrict solOut) {
  // Iterate over elements
  for (int e = 0; e < numElements; ++e; @outer) {
    for (int dummy = 0; dummy < 1; ++dummy; @inner) {
      double grad[NUM_QUAD_1D][NUM_QUAD_1D][2];
      for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
        for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
          grad[qy][qx][0] = 0;
          grad[qy][qx][1] = 0;
        }
      }

      for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
        double gradX[NUM_QUAD_1D][2];
        for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
          gradX[qx][0] = 0;
          gradX[qx][1] = 0;
        }

        for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
          const double s = solIn(dx, dy, e);
          for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            gradX[qx][0] += s * dofToQuad(qx, dx);
            gradX[qx][1] += s * dofToQuadD(qx, dx);
          }
        }

        for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
          const double wy  = dofToQuad(qy, dy);
          const double wDy = dofToQuadD(qy, dy);
          for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            grad[qy][qx][0] += gradX[qx][1] * wy;
            grad[qy][qx][1] += gradX[qx][0] * wDy;
          }
        }
      }

      // Calculate Dxy, xDy in plane
      for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
        for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
          const int q = QUAD_2D_ID(qx, qy);
          const double O11 = oper(0, q, e);
          const double O12 = oper(1, q, e);
          const double O22 = oper(2, q, e);

          const double gradX = grad[qy][qx][0];
          const double gradY = grad[qy][qx][1];

          grad[qy][qx][0] = (O11 * gradX) + (O12 * gradY);
          grad[qy][qx][1] = (O12 * gradX) + (O22 * gradY);
        }
      }

      for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
        double gradX[NUM_DOFS_1D][2];
        for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
          gradX[dx][0] = 0;
          gradX[dx][1] = 0;
        }

        for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
          const double gX = grad[qy][qx][0];
          const double gY = grad[qy][qx][1];
          for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
            const double wx  = quadToDof(dx, qx);
            const double wDx = quadToDofD(dx, qx);
            gradX[dx][0] += gX * wDx;
            gradX[dx][1] += gY * wx;
          }
        }

        for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
          const double wy  = quadToDof(dy, qy);
          const double wDy = quadToDofD(dy, qy);
          for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
            solOut(dx, dy, e) += ((gradX[dx][0] * wy) +
                                  (gradX[dx][1] * wDy));
          }
        }
      }
    }
  }
}
//======================================


//---[ 3D ]-----------------------------
@kernel void Assemble3D(const int numElements,
                       const double * restrict quadWeights,
                       const Jacobian3D_t restrict J,
                       COEFF_ARGS
                       SymmOperator3D_t restrict oper) {
  for (int e = 0; e < numElements; ++e; @outer) {
    for (int q = 0; q < NUM_QUAD_3D; ++q; @inner) {
      const double J11 = J(0, 0, q, e), J12 = J(1, 0, q, e), J13 = J(2, 0, q, e);
      const double J21 = J(0, 1, q, e), J22 = J(1, 1, q, e), J23 = J(2, 1, q, e);
      const double J31 = J(0, 2, q, e), J32 = J(1, 2, q, e), J33 = J(2, 2, q, e);

      const double detJ = ((J11 * J22 * J33) + (J12 * J23 * J31) + (J13 * J21 * J32) -
                           (J13 * J22 * J31) - (J12 * J21 * J33) - (J11 * J23 * J32));

      const double c_detJ = quadWeights[q] * COEFF / detJ;

      // adj(J)
      const double A11 = (J22 * J33) - (J23 * J32);
      const double A12 = (J23 * J31) - (J21 * J33);
      const double A13 = (J21 * J32) - (J22 * J31);

      const double A21 = (J13 * J32) - (J12 * J33);
      const double A22 = (J11 * J33) - (J13 * J31);
      const double A23 = (J12 * J31) - (J11 * J32);

      const double A31 = (J12 * J23) - (J13 * J22);
      const double A32 = (J13 * J21) - (J11 * J23);
      const double A33 = (J11 * J22) - (J12 * J21);

      // adj(J)^Tadj(J)
      oper(0, q, e) = c_detJ * (A11*A11 + A21*A21 + A31*A31); // (1,1)
      oper(1, q, e) = c_detJ * (A11*A12 + A21*A22 + A31*A32); // (1,2), (2,1)
      oper(2, q, e) = c_detJ * (A11*A13 + A21*A23 + A31*A33); // (1,3), (3,1)
      oper(3, q, e) = c_detJ * (A12*A12 + A22*A22 + A32*A32); // (2,2)
      oper(4, q, e) = c_detJ * (A12*A13 + A22*A23 + A32*A33); // (2,3), (3,2)
      oper(5, q, e) = c_detJ * (A13*A13 + A23*A23 + A33*A33); // (3,3)
    }
  }
}

@kernel void MultAdd3D(const int numElements,
                      const DofToQuad_t restrict dofToQuad,
                      const DofToQuad_t restrict dofToQuadD,
                      const QuadToDof_t restrict quadToDof,
                      const QuadToDof_t restrict quadToDofD,
                      const SymmOperator3D_t restrict oper,
                      const DLocal3D_t restrict solIn,
                      DLocal3D_t restrict solOut) {
  // Iterate over elements
  for (int e = 0; e < numElements; ++e; @outer) {
    for (int dummy = 0; dummy < 1; ++dummy; @inner) {
      double grad[NUM_QUAD_1D][NUM_QUAD_1D][NUM_QUAD_1D][4];
      for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
        for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
          for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            grad[qz][qy][qx][0] = 0;
            grad[qz][qy][qx][1] = 0;
            grad[qz][qy][qx][2] = 0;
          }
        }
      }

      for (int dz = 0; dz < NUM_DOFS_1D; ++dz) {
        double gradXY[NUM_QUAD_1D][NUM_QUAD_1D][4];
        for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
          for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            gradXY[qy][qx][0] = 0;
            gradXY[qy][qx][1] = 0;
            gradXY[qy][qx][2] = 0;
          }
        }

        for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
          double gradX[NUM_QUAD_1D][2];
          for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            gradX[qx][0] = 0;
            gradX[qx][1] = 0;
          }

          for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
            const double s = solIn(dx, dy, dz, e);
            for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
              gradX[qx][0] += s * dofToQuad(qx, dx);
              gradX[qx][1] += s * dofToQuadD(qx, dx);
            }
          }

          for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
            const double wy  = dofToQuad(qy, dy);
            const double wDy = dofToQuadD(qy, dy);
            for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
              const double wx  = gradX[qx][0];
              const double wDx = gradX[qx][1];
              gradXY[qy][qx][0] += wDx * wy;
              gradXY[qy][qx][1] += wx  * wDy;
              gradXY[qy][qx][2] += wx  * wy;
            }
          }
        }

        for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
          const double wz  = dofToQuad(qz, dz);
          const double wDz = dofToQuadD(qz, dz);
          for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
            for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
              grad[qz][qy][qx][0] += gradXY[qy][qx][0] * wz;
              grad[qz][qy][qx][1] += gradXY[qy][qx][1] * wz;
              grad[qz][qy][qx][2] += gradXY[qy][qx][2] * wDz;
            }
          }
        }
      }

      // Calculate Dxyz, xDyz, xyDz in plane
      for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
        for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
          for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            const int q = QUAD_3D_ID(qx, qy, qz);
            const double O11 = oper(0, q, e);
            const double O12 = oper(1, q, e);
            const double O13 = oper(2, q, e);
            const double O22 = oper(3, q, e);
            const double O23 = oper(4, q, e);
            const double O33 = oper(5, q, e);

            const double gradX = grad[qz][qy][qx][0];
            const double gradY = grad[qz][qy][qx][1];
            const double gradZ = grad[qz][qy][qx][2];

            grad[qz][qy][qx][0] = (O11 * gradX) + (O12 * gradY) + (O13 * gradZ);
            grad[qz][qy][qx][1] = (O12 * gradX) + (O22 * gradY) + (O23 * gradZ);
            grad[qz][qy][qx][2] = (O13 * gradX) + (O23 * gradY) + (O33 * gradZ);
          }
        }
      }

      for (int qz = 0; qz < NUM_QUAD_1D; ++qz) {
        double gradXY[NUM_DOFS_1D][NUM_DOFS_1D][4];
        for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
          for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
            gradXY[dy][dx][0] = 0;
            gradXY[dy][dx][1] = 0;
            gradXY[dy][dx][2] = 0;
          }
        }

        for (int qy = 0; qy < NUM_QUAD_1D; ++qy) {
          double gradX[NUM_DOFS_1D][4];
          for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
            gradX[dx][0] = 0;
            gradX[dx][1] = 0;
            gradX[dx][2] = 0;
          }

          for (int qx = 0; qx < NUM_QUAD_1D; ++qx) {
            const double gX = grad[qz][qy][qx][0];
            const double gY = grad[qz][qy][qx][1];
            const double gZ = grad[qz][qy][qx][2];
            for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
              const double wx  = quadToDof(dx, qx);
              const double wDx = quadToDofD(dx, qx);
              gradX[dx][0] += gX * wDx;
              gradX[dx][1] += gY * wx;
              gradX[dx][2] += gZ * wx;
            }
          }

          for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
            const double wy  = quadToDof(dy, qy);
            const double wDy = quadToDofD(dy, qy);
            for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
              gradXY[dy][dx][0] += gradX[dx][0] * wy;
              gradXY[dy][dx][1] += gradX[dx][1] * wDy;
              gradXY[dy][dx][2] += gradX[dx][2] * wy;
            }
          }
        }

        for (int dz = 0; dz < NUM_DOFS_1D; ++dz) {
          const double wz  = quadToDof(dz, qz);
          const double wDz = quadToDofD(dz, qz);
          for (int dy = 0; dy < NUM_DOFS_1D; ++dy) {
            for (int dx = 0; dx < NUM_DOFS_1D; ++dx) {
              solOut(dx, dy, dz, e) += ((gradXY[dy][dx][0] * wz) +
                                        (gradXY[dy][dx][1] * wz) +
                                        (gradXY[dy][dx][2] * wDz));
            }
          }
        }
      }
    }
  }
}
//======================================
